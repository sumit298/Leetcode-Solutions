import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## Problem Statement

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.

** Example 1: **

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

** Example 2: **

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
```

** Constraints: **
- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`


### Approach: Brute Force
- In this approach, I will use two nested loops.
- The outer loop will iterate through each day's price as the buying day.
- The inner loop will iterate through the days after the buying day as the selling day.
- For each pair of buying and selling days, I will calculate the profit by subtracting the buying price from the selling price.
- I will keep track of the maximum profit encountered during these calculations
- Finally, I will return the maximum profit. If no profit is possible, I will return 0.


<Tabs>
<TabItem value="java" label="Java" default>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxProfit = Integer.MIN_VALUE;
        for(int i=0; i<prices.length; i++) {
            for(int j = i+1; j< prices.length; j++){
                int profit = prices[j] - prices[i];
                if(profit > maxProfit) {
                    maxProfit = profit;
                }
            }
        }
        return maxProfit;
    }
}
```
</TabItem>
</Tabs>

### Complexity Analysis:  Brute Force 
- Time Complexity: O(n^2), where n is the number of days (length of prices array). This is because we have two nested loops, each iterating through the array.
- Space Complexity: O(1), as we are using only constant extra space.


### Apporach: Two Pointer
- In this approach, I will use two pointers, one for the buying day and another for the selling day.
- I will initialize the buying pointer to the first day and the selling pointer to the second day.
- I will iterate through the array using the selling pointer.
- If the price at the selling pointer is greater than the price at the buying pointer, I will calculate the profit and update the maximum profit if the calculated profit is greater.
- If the price at the selling pointer is less than or equal to the price at the buying pointer, I will move the buying pointer to the selling pointer's position.
- Finally, I will return the maximum profit. If no profit is possible, I will return 0.


<Tabs>
<TabItem value="java" label="Java" default>

```java
class Solution {
    public int maxProfitTwoPointers(int[] prices) {
        int left = 0;
        int right = 1;
        int maxProfit = 0;
        int profit = 0;

        while(right < prices.length) {
            if(prices[left] < prices[right]){
                profit = prices[right] - profit[left];
                maxProfit = Math.max(profit, maxProfit);   
            }
            else {
                left = right;
            }
            right+=1;
        }

        return maxProfit;
    }
}
```
</TabItem>
</Tabs>

### Complexity Analysis: Two Pointer
- Time Complexity: O(n), where n is the number of days (length of prices array). This is because we are iterating through the array once with the right pointer.
- Space Complexity: O(1), as we are using only constant extra space.


### Approach: Greedy
- Take care of two things here, min price to buy and max profilt to sell.
- Initialize minPrice to maximum value and maxProfit to 0.
- Traverse through the array of prices.
- If current price is less than minPrice, update minPrice.
- Else calculate the profit by subtracting current price with minPrice and update maxProfit if the calculated profit is greater than maxProfit.
- Finally return maxProfit.
 

<Tabs>
<TabItem value="java" label="Java" default>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;

        for (int i=0; i<prices.length; i++) {
            if(prices[i] < minPrice) {
                minPrice = prices[i];
            }
            else {
                maxProfit = Math.max(maxProfit, prices[i] - minPrice);
            }
        }
        return maxProfit;
    }
}
```

</TabItem>
</Tabs>

### Complexity Analysis: Greedy
- Time Complexity: O(n), where n is the number of days (length of prices array).
- Space Complexity: O(1), as we are using only constant extra space.






